nor $1,$0,$0;  #$1=FFFF_FFFF      没什么好说的，这边全部都是对于其相关的预测值。而且均为三目运算符，
sltu $2,$0,$1;  #$2=0000_0001     均是将后两个值进行运算后返回给最前面的值。
add $3,$2,$2; #$3=0000_0002     nor是或非运算，add是加法运算，sltu的意思为如果R2的值小于R3，那么设置R1的值为1，否则设置R1的值为0
add $4,$3,$2;  #$4=0000_0003     sllv是第二个参数向左移动第三个参数位，结果保留在第一个参数里
add $5,$4,$3; #$5=0000_0005     xor是异或运算，or是或运算，and是与运算
add $6,$5,$3; #$6=0000_0007
sllv $7,$6,$2; #$7=0000_000E
add $9,$5,$6; #$9=0000_000C
sllv $8,$6,$9; #$8=0000_7000
xor $9,$1,$8; #$9=FFFF_8FFF0
add $10,$9,$1; #$10=FFFF_8FFE
sub $11,$8,$7; #$11=0000_6FF2
sub $12,$7,$8; #$12=FFFF_900E
and $13,$9,$12; #$13=FFFF_800E
or $14,$9,$12; #$14=FFFF_9FFF
or $15,$6,$7; #$15=0000_000F
nor $16,$6,$7; #$16=FFFF_FFF0
add $17,$7,$3; #$17=0000_0010
sllv $18,$8,$17; #$18=7000_0000
sllv $19,$3,$17; #$19=0002_0000
sllv $20,$19,$7; #$20=8000_0000
add $21,$20,$1; #$21=7FFF_FFFF
or $22,$18,$21; #$22=7FFF_FFFF
add $23,$20,$22; #$23=FFFF_FFFF
sub $24,$20,$22; #$24=0000_0001
sub $25,$22,$20; #$25=FFFF_FFFF
xor $26,$18,$1; #$26=8FFF_FFFF
sltu $27,$22,$20; #$27=0000_0001
sltu $28,$26,$20; #$28=0000_0000
add $29,$22,$2; #$29=8000_0000
sub $30,$20,$2; #$30=7FFF_FFFF
add $31,$11,$26; #$30=9000_6FF1